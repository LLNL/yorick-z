---
layout: default
headline: yorick-z package
---
<p class="sectop">Back to <a href="index.html">library index</a>.</p>
<p class="sectop">Package png (in png.i) - </p>
<p class="sectop">Index of documented functions or symbols:</p>
<div class="ndex0s">
  <div class="ndex1">
    <h3>P</h3>
    <p><a href="png.html#png2">png2</a></p>
  </div>
  <div class="ndex2">
    <p><a href="png.html#png_map">png_map</a></p>
    <p><a href="png.html#png_pcal">png_pcal</a></p>
  </div>
  <div class="ndex3">
    <p><a href="png.html#png_read">png_read</a></p>
    <p><a href="png.html#png_scale">png_scale</a></p>
  </div>
</div>
<div class="docblock"><a name="png2"></a><h3>png2</h3>
  <pre>DOCUMENT png2, name
  writes the picture in the current graphics window to the png file
  NAME, or to NAME+".png" is NAME does not end in ".png".</pre>
  <p>SEE ALSO: png, jpeg, pdf, eps, hcps</p>
</div>
<div class="docblock"><a name="png_map"></a><h3>png_map</h3>
  <pre>DOCUMENT image = png_map(full_image, nfo)
  maps FULL_IMAGE to png-stored values, according to the
  pCAL information in NFO.
  The NFO parameter may be either the array of pointers as returned by
  png_read, or an array of reals as for *nfo(4) (see png_read).
  You can use png_pcal to compute an NFO mapping tailored to IMAGE.
</pre>
  <p>SEE ALSO: <a href="png.html#png_pcal">png_pcal</a>, <a href="png.html#png_scale">png_scale</a>, <a href="png.html#png_read">png_read</a>, png_write</p>
</div>
<div class="docblock"><a name="png_pcal"></a><h3>png_pcal</h3>
  <pre>DOCUMENT pcal = png_pcal(image)
      or pcal = png_pcal(image, depth)

KEYWORDS: cmin=, cmax=, res=, log=
  cmin, cmax   clip image to these minimum and maximum values
  res          image "resolution", or minimum step size
  log          non-zero forces log map if image all positive
               or all negative

  returns 8-element pCAL png mapping for IMAGE, appropriate for
  use as pcal= keyword in png_write.  The png_map function applies
  pcal to produce the as-stored char or short array; the png_scale
  function applies pcal to recreate the original IMAGE from the
  as-stored array.

  There are three kinds of pCAL mappings: linear, log, and asinh.
  Linear and log scales are familiar; the asinh scale is a modified
  log scale that can be used for arrays that change sign:

  linear:  image = a*stored + b
  log:     image = b * exp(a*stored)
  asinh:   image = b * sinh(a*(stored - mx/2))

  You can specify a bit DEPTH for the stored array, which can be
  between 2 and 16 inclusive.  For bit depth 1, just threshhold
  the image (image>const_thresh).  By default, for integer IMAGE,
  DEPTH is the smallest depth that covers the range of IMAGE values,
  but never more than 16.  For float or double IMAGE, the default
  DEPTH is always 16.

  If IMAGE has any integer data type, the pCAL mapping will always
  be linear; use IMAGE+0.0 if you want a log or asinh map.

  The png pCAL definition allows b<0 in the log scale, so it can
  be used for image values that are either all positive or all
  negative.  In either case, the integer stored values take equal
  ratio steps from the minimum to the maximum image values (or
  cmin and cmax).  For the linear scale, of course, each step in
  the stored integer represents an constant increment in the image
  value.  The asinh scale is a logarithmic ratio scale for stored
  values near 0 or mx (the maximum stored integer value), reverting
  to a linear scale near the middle of its range where the image
  value passes through zero.

  To get the asinh scale, you must specify the res= keyword:
  You must specify the smallest step size for the asinh scale by
  setting the res= keyword.  For a log scale, the res= value will
  replace the actual minimum array value or cmin value (or cmax if
  image is all negative values), clipping any smaller absolute values.
  If mx is large enough to cover the whole scale with the given res=
  value in linear steps, a linear scale will be used.

  You can specify log=1 to force log scaling if image is all
  positive or all negative.
</pre>
  <p>SEE ALSO: <a href="png.html#png_scale">png_scale</a>, png_write, <a href="png.html#png_read">png_read</a></p>
</div>
<div class="docblock"><a name="png_read"></a><h3>png_read</h3>
  <pre>DOCUMENT image = png_read(filename)
      or image = png_read(filename, depth, nfo)

Read png file FILENAME.  The returned IMAGE is either an array
of char or short, unless type= is specified (see below).
The IMAGE may have a leading dimension of 2 if it is gray+alpha,
3 if it is rgb, or 4 if it is rgba.
In the second form, DEPTH and NFO must be simple variable references.
NFO is set to a pointer array to descriptive information by png_read:
*nfo(1) = PLTE 3-by-N char array of palette rgb values
*nfo(2) = tRNS char array of alpha (opacity) values corresponding
                to PLTE or single gray or rgb short value (transparent)
*nfo(3) = bKGD single gray or rgb short value
             note that bKGD and the single value tRNS have the same
             range and meaning as a pixel value, in particular,
             for a pseudocolor image, they represent a palette index
*nfo(4) = pCAL [x0,x1,max,eqtype,p0,p1,p2,p3,...] physical pixel value
                relation between pixel value and physical value
                array of double values (see below for meaning)
*nfo(5) = pCAL [calibration_name, unit_name] string pair
*nfo(6) = sCAL [wide,high,sunit] physical scale of pixels as scanned
                or printed, sunit 1.0 for meters or 2.0 for radians
*nfo(7) = pHYs long [n_xpix,n_ypix,per_meter] values
                n_xpix,n_ypix are pixels per unit,
                per_meter is 0 for aspect ratio only, 1 for meters
*nfo(8) = tEXt (or zTXt or iTXt) 2-by-N string array of (key,text)
*nfo(9) = tIME string value image modification time
any or all of these NFO values may be nil.  The four character
designators (e.g. PLTE) are the png chunk names for the corresponding
information.

pCAL array of doubles has following meaning:
   max = 2^depth-1
   original = long( floor( (image(i)*(x1-x0)+long(max)/2) / max ) ) + x0
   image(i) = long( floor( ((original-x0)*max+long(x1-x0)/2) / (x1-x0) ) )
   eqtype = 0   physical = p0 + p1*original/(x1-x0)
   eqtype = 1   physical = p0 + p1*exp(p2*original/(x1-x0))
   eqtype = 2   physical = p0 + p1*p2^(original/(x1-x0))
   eqtype = 3   physical = p0 + p1*sinh(p2*(original-p3)/(x1-x0))

If the type= keyword is non-nil and non-zero, the returned value
is as if png_scale(image, nfo, type=type), which scales the raw image
according to the information in pCAL, or is a no-op if pCAL does
not exist.
</pre>
  <p>SEE ALSO: png_write, <a href="png.html#png_scale">png_scale</a></p>
</div>
<div class="docblock"><a name="png_scale"></a><h3>png_scale</h3>
  <pre>DOCUMENT image = png_scale(raw_image, nfo, type=type)
  scales RAW_IMAGE to type TYPE (char, short, int, long, float, or
  double, according to the pCAL information in NFO.  The NFO
  parameter may be either the array of pointers returned by
  png_read, or an array of reals as for *nfo(4) (see png_read).
</pre>
  <p>SEE ALSO: <a href="png.html#png_map">png_map</a>, <a href="png.html#png_read">png_read</a>, png_write</p>
</div>
